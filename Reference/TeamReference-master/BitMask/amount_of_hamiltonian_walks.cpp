/*
	task:           Finding the number of Hamiltonian walks in the 
	                unweighted and directed graph G = (V, E).
	complexity:     O(2^n * n^2)
	notes:          Let dp[msk][v] be the amount of Hamiltonian walks 
	                on the subgraph generated by vertices in msk that 
	                end in the vertex v.
*/
#define BIT(n)  (1 << n)
const int	MAXN = 20;

int n, m, u, v, g[MAXN], dp[BIT(MAXN)][MAXN], ans;

int main()
{
	cin >> n >> m;
	
	for (int i = 0; i < m; ++i)
	{
		cin >> u >> v;
		g[u] |= BIT(v);
	}
	
	for (int i = 0; i < n; ++i)
	    dp[BIT(i)][i] = 1;
	
	for (int msk = 1; msk < BIT(n); ++msk)
	{
		for (int i = 0; i < n; ++i) if (msk & BIT(i))
		{
			int tmsk = msk ^ BIT(i);
			
			for (int j = 0; tmsk && j < n; ++j)
			{
				if (g[j] & BIT(i))
   				    dp[msk][i] += dp[tmsk][j];
			}
		}
	}
	for (int i = 0; i < n; ++i)
	    ans += dp[BIT(n) - 1][i];   
	cout << ans << endl;
	return 0;
}
