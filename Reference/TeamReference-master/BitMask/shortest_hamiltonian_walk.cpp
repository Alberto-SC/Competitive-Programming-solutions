/*
	task:           Search for the shortest Hamiltonian walk. 
					Let the directed graph G = (V, E) have n 
					vertices, and each edge have weight d(i, j). 
					We want to find a Hamiltonian walk for which 
					the sum of weights of its edges is minimal.

	complexity:     O(2^n * n^2)
	
	notes:          Let dp[msk][v] be the length of the shortest 
					Hamiltonian walk on the subgraph generated by 
					vertices in msk that end in vertex v.
*/

#define MAXN    20
#define INF     0x1fffffff
#define BIT(n)  (1 << n)

using namespace std;

int n, m, ans = INF, d[MAXN][MAXN], u, v, w, dp[1 << MAXN][MAXN];

int main()
{
	cin >> n >> m;
	
	for (int i = 0; i < n; ++i)
	{
		for (int j = 0; j < n; ++j)
		    d[i][j] = INF;
	}
	
	for (int i = 0; i < BIT(n); ++i)
	{
		for (int j = 0; j < n; ++j)
		    dp[i][j] = INF;
    }

	for (int i = 0; i < m; ++i)
	{
		cin >> u >> v >> w;
		d[u][v] = w;
	}

	for (int i = 0; i < n; ++i)
	    dp[1 << i][i] = 0;
	    
	for (int msk = 1; msk < (1 << n); ++msk)
	{
		for (int i = 0; i < n; ++i) if (msk & BIT(i))
		{
			int tmsk = msk ^ BIT(i);

			for (int j = 0; tmsk && j < n; ++j)
				dp[msk][i] = min(dp[tmsk][j] + d[j][i], dp[msk][i]);
		}
	}
	
 	for (int i = 0; i < n; ++i)
 	    ans = min(ans, dp[BIT(n) - 1][i]);
 	    
	cout << ans << endl;
	return 0;
}
